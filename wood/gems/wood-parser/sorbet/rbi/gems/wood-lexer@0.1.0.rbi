# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `wood-lexer` gem.
# Please instead update this file by running `bin/tapioca gem wood-lexer`.

# source://wood-lexer-0.1.0/lib/wood/lexer.rb:61
W = Wood

# source://wood-lexer-0.1.0/lib/wood/maybe.rb:3
module Wood; end

# source://wood-lexer-0.1.0/lib/wood/factories.rb:5
module Wood::Factories
  # source:///Users/vaporyhumo/repos/wood/gems/wood-parser/lib/wood/factories.rb:13
  sig { params(left: ::Wood::Node, right: ::Wood::Node).returns(::Wood::Node::Add) }
  def Add(left, right); end

  # source:///Users/vaporyhumo/repos/wood/gems/wood-parser/lib/wood/factories.rb:28
  sig { params(constant: T.untyped, value: T.untyped).returns(::Wood::Node::Asgn) }
  def Asgn(constant, value); end

  # source:///Users/vaporyhumo/repos/wood/gems/wood-parser/lib/wood/factories.rb:18
  sig { params(char: ::String).returns(::Wood::Node::Char) }
  def Char(char); end

  # source:///Users/vaporyhumo/repos/wood/gems/wood-parser/lib/wood/factories.rb:8
  sig { params(value: ::Integer).returns(::Wood::Node::Int) }
  def Int(value); end

  # source:///Users/vaporyhumo/repos/wood/gems/wood-parser/lib/wood/factories.rb:23
  sig { params(receiver: T.untyped, message: T.untyped).returns(::Wood::Node::Send) }
  def Send(receiver, message); end

  # source://wood-lexer-0.1.0/lib/wood/factories.rb:9
  sig { params(type: T.any(::Symbol, ::Wood::TokenType), lexeme: ::String).returns(::Wood::Token) }
  def Token(type, lexeme); end
end

# source://wood-lexer-0.1.0/lib/wood/lexer.rb:59
Wood::L = Wood::Lexer

# source://wood-lexer-0.1.0/lib/wood/lexer.rb:12
module Wood::Lexer
  extend ::Wood::Factories

  class << self
    # source://wood-lexer-0.1.0/lib/wood/lexer.rb:18
    sig { params(string: ::String).returns(T::Array[::Wood::Token]) }
    def call(string); end

    # source://wood-lexer-0.1.0/lib/wood/lexer.rb:38
    sig { params(char: ::String).returns(T.nilable(::Wood::Token)) }
    def for_char(char); end

    # source://wood-lexer-0.1.0/lib/wood/lexer.rb:50
    sig { params(string: ::String).returns(T.nilable(::Wood::Token)) }
    def for_string(string); end

    # source://wood-lexer-0.1.0/lib/wood/lexer.rb:25
    sig { params(tokens: T::Array[::Wood::Token], char: ::String).returns(T::Array[::Wood::Token]) }
    def lex_step(tokens, char); end
  end
end

# source://wood-lexer-0.1.0/lib/wood/lexer/version.rb:5
Wood::Lexer::VERSION = T.let(T.unsafe(nil), String)

# source://wood-lexer-0.1.0/lib/wood/maybe.rb:4
class Wood::Maybe
  # source://wood-lexer-0.1.0/lib/wood/maybe.rb:20
  sig { params(val: ::BasicObject).void }
  def initialize(val); end

  # source://wood-lexer-0.1.0/lib/wood/maybe.rb:27
  sig { params(other: ::BasicObject).returns(T::Boolean) }
  def ==(other); end

  # source://wood-lexer-0.1.0/lib/wood/maybe.rb:35
  sig { params(blk: T.untyped).returns(::Wood::Maybe) }
  def bind(&blk); end

  # @return [String]
  #
  # source://sorbet-runtime-0.5.10326/lib/types/private/methods/_methods.rb:250
  def inspect(*args, **_arg1, &blk); end

  # source://wood-lexer-0.1.0/lib/wood/maybe.rb:43
  sig { returns(::String) }
  def to_s; end

  protected

  # source://wood-lexer-0.1.0/lib/wood/maybe.rb:10
  sig { returns(::BasicObject) }
  def val; end

  class << self
    # source://wood-lexer-0.1.0/lib/wood/maybe.rb:15
    sig { params(val: ::BasicObject).returns(T.attached_class) }
    def return(val); end
  end
end

# source:///Users/vaporyhumo/repos/wood/gems/wood-parser/lib/wood/parser.rb:147
Wood::P = Wood::Parser

# source://wood-lexer-0.1.0/lib/wood/token.rb:5
class Wood::Token
  # source://wood-lexer-0.1.0/lib/wood/token.rb:15
  sig { params(type: ::Wood::TokenType, lexeme: ::String).void }
  def initialize(type, lexeme); end

  # source://wood-lexer-0.1.0/lib/wood/token.rb:22
  sig { params(other: ::Wood::Token).returns(T::Boolean) }
  def ==(other); end

  # @param other [::Wood::Token]
  # @return [Boolean]
  #
  # source://sorbet-runtime-0.5.10326/lib/types/private/methods/_methods.rb:250
  def eql?(*args, **_arg1, &blk); end

  # @return [String]
  #
  # source://sorbet-runtime-0.5.10326/lib/types/private/methods/_methods.rb:250
  def inspect(*args, **_arg1, &blk); end

  # source://wood-lexer-0.1.0/lib/wood/token.rb:12
  sig { returns(::String) }
  def lexeme; end

  # source://wood-lexer-0.1.0/lib/wood/token.rb:28
  sig { returns(::String) }
  def to_s; end

  # source://wood-lexer-0.1.0/lib/wood/token.rb:9
  sig { returns(::Wood::TokenType) }
  def type; end
end

# source://wood-lexer-0.1.0/lib/wood/token_type.rb:4
class Wood::TokenType < ::T::Enum
  enums do
    Asgn = new
    Char = new
    Dot = new
    IChar = new
    ID = new
    Int = new
    Plus = new
  end

  # @return [String]
  #
  # source://sorbet-runtime-0.5.10326/lib/types/private/methods/_methods.rb:250
  def inspect(*args, **_arg1, &blk); end

  # source://wood-lexer-0.1.0/lib/wood/token_type.rb:47
  sig { returns(::String) }
  def to_s; end

  class << self
    # source://wood-lexer-0.1.0/lib/wood/token_type.rb:18
    sig { params(char: ::String).returns(T.nilable(::Wood::TokenType)) }
    def for_char(char); end

    # source://wood-lexer-0.1.0/lib/wood/token_type.rb:33
    sig { params(string: ::String).returns(T.nilable(::Wood::TokenType)) }
    def for_string(string); end
  end
end
